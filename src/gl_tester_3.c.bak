#include <SDL2/SDL.h>
#include "structures/types.h"
#include "structures/shader.h"
#include "structures/components/light_component.h"
#include <stb/stb_dxt.h>
#include "miniz.h"
#include "io.h"

SDL_Window *window;
const int width = 1024; // ширина окна
const int height = 640; // высота окна
bool running = true;

//#define STB_IMAGE_IMPLEMENTATION
//#include <stb/stb_image.h>
//#define STB_IMAGE_WRITE_IMPLEMENTATION
//#include <stb/stb_image_write.h>
void screenshot(char* fname)
{
    glc(glBindFramebuffer(GL_FRAMEBUFFER, 0));
    char (*data)[width][3] = (char(*)[width][3])malloc((height+1)*width*3);
    glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, data);
    for (int i=0; i<height/2; i++) {
        void *buffer = data[height];
        memcpy(buffer, data[i], width*3);
        memcpy(data[i], data[height-i-1], width*3);
        memcpy(data[height-i-1], buffer, width*3);
    }
    stbi_write_jpg(fname, width, height, 3, data, 100);
    free(data);
}

int pmx, pmy;
int pbtn;
laMatrix center = {{1.0,0.0,0.0}, 4};
float dist = 10.0;
float angle_x = 63.6+10.0, angle_z = 46.7-70.0;

sGameObjectID* draw_list = 0;
sGameObjectID* lights_list = 0;
sGameObjectID camera;
sGameObjectID object;
sGameObjectID spotlight;
sMeshID monkey;
sMaterialID material;
sTextureID texture;
sTextureID normalmap;
sTextureID cubemap;
sMaterialID plane_material;

int buttons[SDL_NUM_SCANCODES];
int buttons_delta[SDL_NUM_SCANCODES];

void mouse_look(bool fr)
{
    int dx, dy;
    int btn = SDL_GetRelativeMouseState(&dx, &dy);
    
    int numkeys;
    const uint8_t* keyboard = SDL_GetKeyboardState(&numkeys);
    if (btn!=pbtn) {
        SDL_GetMouseState(&pmx, &pmy);
        pbtn = btn;
        return;
    }
    if (btn==2 || fr) {
        if (keyboard[SDL_SCANCODE_LSHIFT]) {
            laMatrix xdir = laMulf(laMatrixGetXDirection(camera->transform.global), -dx*0.0004*dist);
            laMatrix ydir = laMulf(laMatrixGetYDirection(camera->transform.global),  dy*0.0004*dist);
            center = laAdd(center, laAdd(xdir, ydir));
        } else {
            angle_x -= dy * 0.15;
            angle_z -= dx * 0.15;
            camera->transform.global = laRotationXYZ(radians(angle_x), 0.0f, radians(angle_z));
        }
        camera->transform.global.a[3]  = center.a[0] + camera->transform.global.a[ 2] * dist;
        camera->transform.global.a[7]  = center.a[1] + camera->transform.global.a[ 6] * dist;
        camera->transform.global.a[11] = center.a[2] + camera->transform.global.a[10] * dist;
        SDL_GetMouseState(&pmx, &pmy);
        pmx = pmx + (width-1) * ((pmx<=0) - (pmx>=(width-1)));
        pmy = pmy + (height-1) * ((pmy<=0) - (pmy>=(height-1)));
        SDL_WarpMouseInWindow(window, pmx, pmy);
    }
    pbtn = btn;
    for (int i=0; i<SDL_NUM_SCANCODES; i++)
    {
        if (keyboard[i])
        {
            if (i==SDL_SCANCODE_LEFT  && plane_material->roughness>0.01)
            {
                plane_material->roughness -= 0.01;
            }
            if (i==SDL_SCANCODE_RIGHT && plane_material->roughness<0.99)
            {
                plane_material->roughness += 0.01;
            }
        }
        buttons[i] = keyboard[i];
    }
    fflush(stdout);
}

void create_simple_scene(void);

void gc_test(void)
{
    printf("Mem %lu\n", sGetAllocatedMem());
    create_simple_scene();

    sGameObjectClear();
    sMeshClear();
    sMaterialClear();
    sShaderClear();
    sTextureClear();
    sShaderDeleteDict();

    sDelete(draw_list);
    printf("Mem %lu\n", sGetAllocatedMem());
}

void create_plane(void)
{
    sMeshID plane_mesh = sMeshLoad((char*)"data/mesh/plane.mesh");
    sGameObjectID plane_obj = sGameObjectCreate((char*)"plane");
    plane_material = sMaterialCreateWithDefaultShader((char*)"plane_material");
    sMaterialSetDiffuseMap(plane_material, sTextureLoadDDS((char*)"/home/ivan/SGM_SDK/SGE_2.0/data/textures/pbr/hardwood-brown-planks-bl/hardwood-brown-planks-albedo.dds"));
    //sMaterialSetRoughnessMap(plane_material, sTextureLoadDDS((char*)"/home/ivan/SGM_SDK/SGE_2.0/data/textures/pbr/hardwood-brown-planks-bl/hardwood-brown-planks-roughness.dds"));
    //sMaterialSetHeightMap(plane_material, sTextureLoadDDS((char*)"/home/ivan/SGM_SDK/SGE_2.0/data/textures/pbr/hardwood-brown-planks-bl/hardwood-brown-planks-normal-ogl.dds"));
    plane_material->metallic = 0.0;
    plane_material->roughness = 0.5;
    plane_material->diffuse = (sColor){1.0,1.0,1.0,1.0};
    sMeshSetMaterial(plane_mesh, plane_material);
    sGameObjectSetVisual(plane_obj, plane_mesh);
    sListPushBack(draw_list, plane_obj);
    /*for (int i=0; i<12; i++) {
        if ((i&0b11) < 3) {
            plane_obj->transform.global.a[i] *= 2.0;
        }
    }*/
}

void create_light(void)
{
    //sMeshID lp = sMeshLoad("data/mesh/lightpoint.mesh");
    //sMeshSetMaterial(lp, material);
    
    spotlight = sGameObjectCreate((char*)"spotlight");
    spotlight->transform.global = laRotationXYZ(radians(37.261), radians(3.16371), radians(106.936));
    spotlight->transform.global.a[3]  = 4;
    spotlight->transform.global.a[7]  = 1;
    spotlight->transform.global.a[11] = 2;
    //spotlight->transform.global = laIdentity;
    spotlight->light_component = sLightCreateShadowBuffer(512, sLightSun);
    spotlight->light_component->user = spotlight;
    spotlight->light_component->color = (sColor){
        50.0,
        50.0,
        50.0,1.0};

    sListPushBack(lights_list, spotlight);
    //sListPushBack(draw_list, spotlight);
}

void create_simple_scene(void)
{
    //sShaderID dm = sShaderMakeFromFiles((char*)"data/shaders/vertex.glsl", (char*)"data/shaders/fragment.glsl");
    camera = sGameObjectCreate((char*)"camera");
    object = sGameObjectCreate((char*)"monkey");
    monkey = sMeshLoad((char*)"data/mesh/monkey.mesh");
    material = sMaterialCreateWithDefaultShader((char*)"monkey_material");
    material->diffuse = (sColor){0.5,0.5,0.5,1};
    normalmap = sTextureLoadDDS((char*)"data/textures/hexa_holes_large_nrm.dds");
    //cubemap = sTextureLoadDDSCubemap((char*)"/home/ivan/SGM_SDK/SGE/data/textures/cubemap/kitchen_shup.dds");
    
    //sTextureCubeSplit(cubemap);
    //sMaterialSetDiffuseMap(material, sTextureLoadDDS((char*)"/home/ivan/SGM_SDK/SGE_2.0/data/textures/pbr/rustediron1-alt2-bl/rustediron2_basecolor.dds"));
    //sMaterialSetHeightMap(material, sTextureLoadDDS((char*)"/home/ivan/SGM_SDK/SGE_2.0/data/textures/pbr/rustediron1-alt2-bl/rustediron2_normal.dds"));
    //sMaterialSetMetallicMap(material, sTextureLoadDDS((char*)"/home/ivan/SGM_SDK/SGE_2.0/data/textures/pbr/rustediron1-alt2-bl/rustediron2_metallic.dds"));
    //sMaterialSetRoughnessMap(material, sTextureLoadDDS((char*)"/home/ivan/SGM_SDK/SGE_2.0/data/textures/pbr/rustediron1-alt2-bl/rustediron2_roughness.dds"));
    material->metallic = 0.0;
    material->roughness = 0.02;

    sMeshSetMaterial(monkey, material);
    sGameObjectSetVisual(object, monkey);
    sListPushBack(draw_list, object);
    camera->camera_component = sCameraInitDeferredRenderer(width, height, 80.0);
    camera->camera_component->user = camera;
    camera->transform.global = laRotationXYZ(radians(63.6), 0.0f, radians(46.7));
    camera->transform.global.a[3]  = 7.35889;
    camera->transform.global.a[7]  =-6.50764;
    camera->transform.global.a[11] = 4.95831 + 1;
    
    //object->transform.global = laIdentity;
    object->transform.global.a[11] = 1.0;
    create_light();
    create_plane();
    mouse_look(1);
}
void draw(void)
{
    if (spotlight && spotlight->light_component && spotlight->light_component->rpclbk)
    {
        spotlight->light_component->rpclbk(spotlight->light_component, draw_list);
    }
    camera->camera_component->rpclbk(camera->camera_component, draw_list, lights_list);
}

void gen_fa_mat(float* arr, uint16_t size, float(*fu)(float,float));
void gen_dct_mat(float* arr, uint16_t size);
int main(int argc, char *argv[])
{
    /*FILE* fp = fopen("gl_tester", "rb");
    void* source = sNewArray(uint8_t, sizef(fp));
    void* cmp = sNewArray(uint8_t, sSizeof(source));
    mz_ulong cmp_size;
    printf("sSizeof(source) -> %d\n", (int)sSizeof(source));
    readf(source, sSizeof(source), 1, fp);
    mz_uncompress(cmp, &cmp_size, source, sSizeof(source));
    fclose(fp);
    fp = fopen("gl_tester.z", "wb");
    fwrite(cmp, cmp_size, 1, fp);
    fclose(fp);
    sDelete(source);
    sDelete(cmp);
    return 0;*/
    /*int n = 15;
    float mat[n][n];
    float inv[n][n];
    float check[n][n];
    gen_dct_mat(mat, n);
    laInvertArray(inv, mat, n);
    laMulArrays((float*)check, (float*)mat,n,n, (float*)inv,n,n);
    laWriteCSV("mat.csv", (float*)mat, n);
    laWriteCSV("out.csv", (float*)check, n);
    return 0;*/
    if (SDL_Init(SDL_INIT_VIDEO))
    {
        printf("SDL2 initialization failed: %s\n", SDL_GetError());
        return 1;
    }

    //int r,g,b,a;
    SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    //SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
    //SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 8);


    window = SDL_CreateWindow((char*)"Cube", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_SHOWN | SDL_WINDOW_OPENGL);
    SDL_GLContext glcontext = SDL_GL_CreateContext(window);
    if(window == NULL)
    {
        return 1;
    }

    SDL_GL_SetSwapInterval(0);

    #ifdef GLAD
    gladLoadGL();
    #endif
    #ifdef GLEW
    glewInit();
    #endif

    sShaderSetVersion((const char*)glGetString(GL_SHADING_LANGUAGE_VERSION));
    printf("Mem %lu\n", sGetAllocatedMem());
    create_simple_scene();
    glc(glDisable(GL_DEPTH_TEST));
    glc(glDisable(GL_CULL_FACE));
    glc(glEnable(GL_MULTISAMPLE));
    glc(glEnable(GL_BLEND));
    float a = 0.0;

    sTextureID sky = sTextureCreateCubemap("Skybox", 512, 512, RGB16F, 1, 1);
    sTextureCubeSplit(sky);
    sCameraComponentBakeSkybox(sky);
    sTextureGenerateMipMaps(sky);
    cubemap = sky;
    //sTextureSave(sky->sides[0], "side1.png");
    //sTextureSave(sky->sides[1], "side2.png");
    //sTextureSave(sky->sides[2], "side3.png");
    //sTextureSave(sky->sides[3], "side4.png");
    //sTextureSave(sky->sides[4], "side5.png");
    //sTextureSave(sky->sides[5], "side6.png");

    while (running){
        SDL_Event event; // события SDL

		while ( SDL_PollEvent(&event) ){ // начинаем обработку событий
			switch(event.type){ // смотрим:
            case SDL_QUIT: // если произошло событие закрытия окна, то завершаем работу программы
                running = false;
                break;

            case SDL_KEYDOWN: // если нажата клавиша
                switch(event.key.keysym.sym){ // смотрим какая
                    case SDLK_ESCAPE: // клавиша ESC
                    running = false; // завершаем работу программы
                    break;
                }
                break;
			}
		}
        mouse_look(0);
        object->transform.global = laRotationXYZ(0.0, 0.0, a);
        //a += 0.01f;
        object->transform.global.a[11] += 1.0;
        //spotlight->transform.global.a[3] -= spotlight->transform.global.a[2] * 0.1;
        //spotlight->transform.global.a[7] -= spotlight->transform.global.a[6] * 0.1;
        //spotlight->transform.global.a[11] -= spotlight->transform.global.a[10] * 0.1;
        draw();
        glFlush();
        screenshot("scrn.jpg");
		SDL_GL_SwapWindow(window);
        running = 0;
    }
    sGameObjectClear();
    sMeshClear();
    sMaterialClear();
    sShaderClear();
    sTextureClear();
    sShaderDeleteDict();
    sDelete(draw_list);
    sDelete(lights_list);

    printf("Mem %lu\n", sGetAllocatedMem());
    //puts(glGetString(GL_SHADING_LANGUAGE_VERSION));
    SDL_Quit();

    laPrint(laPerspective(1024, 1024, 0.1, 100.0, 90.0));
    laPrint(laInverted(laPerspective(1024, 1024, 0.1, 100.0, 90.0)));

    return 0;
}
